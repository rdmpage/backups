Appendix 1: Description of the UMP algorithm used to combine all MP trees into a single graph. Input file: nexus file (Maddison et al., 1997) with trees, including branch length information, in the Newick Standard tree format (evolution.genetics.washington.edu/phylip/ newicktree.html).Output file generated by the algorithm: a text file with a list of connections (among all missing node and sampled haplotypes) defining a ÒUMP graphÓ.Definitions:Node haplotype: haplotype connected to three or more neighbors in a graph.Branch haplotype: haplotype connected to exactly two neighbors in a graph.Tip haplotype: haplotype connected to a single neighbor in a graph.Missing haplotype: haplotype shown in a graph but not present in the input data set for the maximum parsimony analysis.Sampled haplotype: haplotype present in the input data set for the maximum parsimony analysis.Note that node and branch haplotypes can be sampled or missing, and that tip haplotypes are always sampled.Direct path between haplotypes: a path on the graph that joins two given haplotypes, without passing through a sampled haplotype.The length of a direct path is given by the number of mutations separating the starting haplotype from the haplotype at the end of the path. Node and branch haplotypes along a direct path are ordered, thereby occupying each a defined position.Let ti be the ith of the n trees included in the input file.Let   be the vth of the m missing node haplotypes associated to tree ti.Let   be the ath of the k sampled haplotypes associated to tree ti.For each pair of sampled haplotypes {h_, h_}, let S(h_, h_ ) be the set of all direct paths Si(h_, h_ ), in all trees, for which the path length is minimum but greater than 1.Algorithm:1.1.	All missing node haplotypes are given a unique label.1.2.	do1.2.1.	_ {ti, tj}, i­j, i _ [1, É,n], j _ [1, É,n]1.2.1.1.	_ { ,  }, v­w, v _ [1, É,m], w _ [1, É,m]1.2.1.1.1.1.	re-labeling of nodes (give identical label to  and  if conditions 1 and 2 are satisfied)while (re-labeling of nodes has occurred)1.1.	randomly walk through  1.1.1.	if   > 11.1.1.1.	_ {ti, tj}, i­j , i _ [1, É,n], j _ [1, É,n], for which Si(h_, h_ ) and Sj(h_, h_) _ S(h_, h_ ) 1.1.1.1.1.	re-labeling of nodes and branch haplotypes along the path of the Si(h_, h_ ) _ S(h_, h_ ) (give identical label to haplotypes in ti and tj if conditions 3 and 4 are satisfied)condition 1: we can find at least two cases of a direct path from haplotype  and  , to a second haplotype   for which path lengths are identical in tree i and tree j.condition 2: Consider all   included in (1) a direct path from haplotype  and , to a second haplotype , for which path lengths are DIFFERENT in tree i and tree j or (2) a direct path from haplotype  to a second haplotype  , for which the corresponding direct path from  to a second haplotype   does not exist. For these , there are less than two instances, for  a ­g, where d( , ) = d( , ), with   being a sampled haplotype with a direct path to  or .condition 3: the compared haplotypes are at the same position in Si(h_, h_ ) and Sj(h_, h_ ) condition 4:   (and  , in the case where two node haplotypes are compared) do not existExample:The input file consists in trees t1 to t3 of Figure 3a. It is formatted as follows (PAUP tree output file):#NEXUS Begin trees;  tree1 = ((a:2,e:3):1,((c:2,d:3):0,(b:3,f:4):1):0);tree2 = ((a:2,e:3):1,(((c:2,d:3):0,b:4):0,f:4):0);tree3 = ((a:2,b:3):1,(((c:2,d:3):0,e:4):0,f:4):0);End;Below, we give examples of testing conditions 1 to 4.Example of testing condition 1:Comparison of missing node haplotypes   and  . We need to consider all the direct paths from  and  to sampled haplotypes. 	 Sampled haplotype	Path lengthA	2B	5C	3D	4E	3F	5 	 Sampled haplotype	Path lengthA	2B	3C	3D	4E	5F	5There are at least two cases of a direct path from haplotype and  to a second sampled haplotype for which path lengths are identical in tree 1 and 3 (there are actually 4 cases, to A, C, D, and F). Condition 1 is satisfied.Example of testing condition 2:Lets consider the direct paths from haplotype and  to a second sampled haplotype for which path lengths are DIFFERENT in tree 1 and 3: there are two cases, to haplotypes B and E. So we consider, for the two nodes ( and ), the paths of sampled haplotypes B and E to all the other sampled haplotypes connected to  and . 	 path	Path lengthB-A	7B-C	6B-D	7B-E	8B-F	8E-A	5E-B	8E-C	6E-D	7E-F	8 	 path	Path lengthB-A	5B-C	6B-D	7B-E	8B-F	8E-A	7E-B	8E-C	6E-D	7E-F	8Because there is more than 1 path with the same length (ex: d(B,C) in tree 1 = d(B,C) in tree 3 = 6; d(E,B) in tree 1 = d(E,B) in tree 3 = 8),  and  are not given the same label.Example of testing conditions 3 and 4:We compare two direct paths between sampled haplotypes B and C, in trees 1 and 2. Each line describes one path, i.e. the haplotypes encountered along the path, with unnamed branch haplotypes represented by dashes: path in tree 2:		C -     - - B path in tree 1:		C -   -  - - B  and  are at the same position along the path (condition 3).   or   do not exist (condition 4). Therefore,  and  are given the same label. Similarly, a branch haplotype (-) in tree 1 is given the same label as . After these two comparisons, the path both in tree 1 and in tree 2 will be updated as follows: C -     - - BHere is one possible output of the algorithm:U0 _ U1 Dist: 1; U0 _ A Dist: 2; U0 _ E Dist: 3; U1 _ C Dist: 2; U1 _ D Dist: 3; U1 _ U2 Dist: 1; U2 _ B Dist: 3; U2 _ F Dist: 4; U1 _ F Dist: 4This would result in the following graphical representation:Note that this result is equivalent, but somewhat graphically different from the left union graph presented in Figure 3b. Indeed, connections U1-F and U2-F are partially merged in figure 3b. An additional step (merging branches and branch nodes starting from tip nodes) in our algorithm can lead to this graphical simplification. The 8 branches and 8 branch nodes that would be merged are indicated as dashed in the figure above. However, implementing this additional step would not modify the number of errors or the number of loops calculated for the comparison of maximum parsimony to algorithmic methods presented in this study.